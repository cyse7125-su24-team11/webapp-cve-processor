package main

import (
	"archive/zip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/IBM/sarama"
	"github.com/sirupsen/logrus"
)

type JSONData struct {
	CVEMetadata struct {
		CVEID             string `json:"cveId"`
		AssignerOrgId     string `json:"assignerOrgId"`
		AssignerShortName string `json:"assignerShortName"`
		DatePublished     string `json:"datePublished"`
		DateRejected      string `json:"dateRejected"`
		DateReserved      string `json:"dateReserved"`
		DateUpdated       string `json:"dateUpdated"`
		State             string `json:"state"`
	} `json:"cveMetadata"`
	DataType    string `json:"dataType"`
	DataVersion string `json:"dataVersion"`
}

func main() {

	logrus.SetFormatter(&logrus.JSONFormatter{})

	zipURL := os.Getenv("ZIP_URL")
	if zipURL == "" {
		zipURL = "https://github.com/CVEProject/cvelistV5/releases/download/cve_2024-07-26_0000Z/2024-07-26_delta_CVEs_at_0000Z.zip" // Default URL
	}

	fileName := filepath.Base(zipURL)
	downloadPath := filepath.Join("/opt/app", fileName)
	extractPath := "/opt/app"

	logrus.WithFields(logrus.Fields{
        "zipURL":       zipURL,
        "downloadPath": downloadPath,
        "extractPath":  extractPath,
    }).Info("Starting file download")

	// Download the file
    err := downloadFile(zipURL, downloadPath)
    if err != nil {
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
            "zipURL": zipURL,
            "downloadPath": downloadPath,
        }).Error("Error downloading file")
        return
    }

	// Unzip the file and get the extracted folder path
    extractedFolderPath, err := unzip(downloadPath, extractPath)
    if err != nil {
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
            "downloadPath": downloadPath,
            "extractPath": extractPath,
        }).Error("Error unzipping file")
        return
    }

	logrus.WithFields(logrus.Fields{
        "extractedFolderPath": extractedFolderPath,
    }).Info("Download and unzip completed successfully")

	fmt.Printf("Extracted folder path: %s\n", extractedFolderPath)

	// Construct the root path where JSON files are located
	rootPath := filepath.Join(extractedFolderPath, "deltaCves") // Adjusted based on your input

	// Kafka brokers configuration
	brokers := []string{
		"kafka-broker-0-external.kafka-ns.svc.cluster.local:9094",
		// "kafka-broker-1-external.kafka-ns.svc.cluster.local:9094",
		// "kafka-broker-2-external.kafka-ns.svc.cluster.local:9094",
	}

	topic := "push_cve_records"
	// Kafka configuration
	config := sarama.NewConfig()
	config.Producer.Return.Successes = true

	// Create Kafka client
	client, err := sarama.NewClient(brokers, config)
	if err != nil {
        // Log the error with logrus and exit the program
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
        }).Fatal("Error creating Kafka client")
    }
	defer client.Close()

	// Create Kafka producer
	producer, err := sarama.NewSyncProducer(brokers, config)
	if err != nil {
        // Log the error with logrus and exit the program
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
        }).Fatal("Error creating Kafka producer")
    }

	defer func() {
    if err := producer.Close(); err != nil {
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
        }).Error("Error closing Kafka producer")
    }
	}()

	var wg sync.WaitGroup

	// Channel for handling errors
	errors := make(chan error)

	// Walk through the root directory to find JSON files
	err = filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			logrus.WithFields(logrus.Fields{
				"path": path,
				"error": err.Error(),
			}).Error("Error accessing path")
			return fmt.Errorf("error accessing path %s: %v", path, err)
		}

		if !info.IsDir() && strings.HasSuffix(path, ".json") {
			wg.Add(1)
			go func(jsonPath string) {
				defer wg.Done()
				err := processJSONFile(jsonPath, producer, topic, brokers, config)
				if err != nil {
					logrus.WithFields(logrus.Fields{
						"jsonPath": jsonPath,
						"error":    err.Error(),
					}).Error("Error processing file")
					errors <- fmt.Errorf("error processing file %s: %v", jsonPath, err)
				}
			}(path)
		}

		return nil
	})

	if err != nil {
		logrus.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Fatal("Error walking through directories")
		log.Fatalf("Error walking through directories: %v", err)
	}

	go func() {
		wg.Wait()
		close(errors)
	}()

	// Handling errors from goroutines
	for err := range errors {
		logrus.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Error("Error processing file")		
		log.Printf("Error processing file: %v", err)
	}

	logrus.Info("All JSON files processed.")

}

func processJSONFile(filePath string, producer sarama.SyncProducer, topic string, brokers []string, config *sarama.Config) error {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"filePath": filePath,
			"error":    err.Error(),
		}).Error("Error reading file")
	
		return fmt.Errorf("error reading file %s: %v", filePath, err)
	}

	var jsonDataStruct JSONData
	err = json.Unmarshal(data, &jsonDataStruct)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Error("Error unmarshalling JSON data")
		return fmt.Errorf("error unmarshalling JSON data: %v", err)
	}

	// Convert JSONData to JSON string
	jsonString, err := json.Marshal(jsonDataStruct)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Error("Error unmarshalling JSON data")
		return fmt.Errorf("error marshalling JSON data: %v", err)
	}

	// Retry sending message with metadata refresh on error
	retries := 3
	for i := 0; i < retries; i++ {
		partitionID, err := getPartitionLeader(producer, topic)
		if err != nil {
			logrus.WithFields(logrus.Fields{
				"error": err.Error(),
			}).Error("Error getting partition leader")
			return fmt.Errorf("error getting partition leader: %v", err)
		}

		// Send the message to the leader broker
		partitionMsg := &sarama.ProducerMessage{
			Topic:     topic,
			Partition: partitionID,
			Value:     sarama.StringEncoder(jsonString),
		}

		_, _, err = producer.SendMessage(partitionMsg)
		if err == nil {
			logrus.WithFields(logrus.Fields{
				"partitionID": partitionID,
			}).Info("Message sent to partition")
			// log.Printf("Message sent to partition %d", partitionID)
			return nil
		}

		log.Printf("Error sending message to Kafka: %v", err)

		// Check if the error is due to metadata out-of-date
		if strings.Contains(err.Error(), "metadata is out of date") {
			// Refresh metadata by recreating the producer
			newProducer, err := sarama.NewSyncProducer(brokers, config)
			if err != nil {
				return fmt.Errorf("error recreating producer: %v", err)
			}
			producer.Close()
			producer = newProducer

			// Backoff before retry
			time.Sleep(1 * time.Second)
			continue
		}

		// If it's a different type of error, log and return
		return fmt.Errorf("error sending message to Kafka: %v", err)
	}

	return fmt.Errorf("failed to send message after %d retries", retries)
}

// Helper function to get partition leader
func getPartitionLeader(producer sarama.SyncProducer, topic string) (int32, error) {
	// Send a dummy message to get the partition leader
	msg := &sarama.ProducerMessage{
		Topic: topic,
		Value: sarama.StringEncoder("dummy"),
	}

	_, partition, err := producer.SendMessage(msg)
	if err != nil {
		return -1, fmt.Errorf("error sending message to get partition leader: %v", err)
	}

	return int32(partition), nil // Convert int64 to int32
}

func downloadFile(url string, filePath string) error {
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("error downloading file: %v", err)
	}
	defer resp.Body.Close()

	out, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("error creating file: %v", err)
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return fmt.Errorf("error copying content to file: %v", err)
	}

	return nil
}

// unzip extracts a zip archive to the specified directory and returns the path to the extracted folder.
func unzip(zipFile string, destDir string) (string, error) {
	reader, err := zip.OpenReader(zipFile)
	if err != nil {
		return "", fmt.Errorf("error opening zip file: %v", err)
	}
	defer reader.Close()

	var extractedFolderPath string

	for _, file := range reader.File {
		filePath := filepath.Join(destDir, file.Name)

		if file.FileInfo().IsDir() {
			err := os.MkdirAll(filePath, os.ModePerm)
			if err != nil {
				return "", fmt.Errorf("error creating directory: %v", err)
			}
			if extractedFolderPath == "" {
				extractedFolderPath = filePath // Set the first directory as the extracted folder path
			}
			continue
		}

		err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm)
		if err != nil {
			return "", fmt.Errorf("error creating directory: %v", err)
		}

		outFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return "", fmt.Errorf("error opening output file: %v", err)
		}

		rc, err := file.Open()
		if err != nil {
			outFile.Close()
			return "", fmt.Errorf("error opening file from zip: %v", err)
		}

		_, err = io.Copy(outFile, rc)
		outFile.Close()
		rc.Close()

		if err != nil {
			return "", fmt.Errorf("error extracting file: %v", err)
		}
	}

	// Return the path to the extracted folder
	return extractedFolderPath, nil
}
