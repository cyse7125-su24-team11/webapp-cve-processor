package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
	"errors"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type CVERecord struct {
	CVEID            string          `gorm:"column:cve_id;type:varchar(20);not null"`
	AssignerOrgId    string          `gorm:"column:assigner_org_id;type:varchar(100);not null"`
	AssignerShortName string         `gorm:"column:assigner_short_name;type:varchar(100);not null"`
	Description      string          `gorm:"column:description;type:text"`
	// AffectedProduct  string          `gorm:"column:affected_product;type:varchar(255)"`
	// AffectedVendor   string          `gorm:"column:affected_vendor;type:varchar(255)"`
	// AffectedVersion  string          `gorm:"column:affected_version;type:varchar(255)"`
	DatePublished    string          `gorm:"column:date_published;type:varchar(255)"`
	DateRejected     string          `gorm:"column:date_rejected;type:varchar(255)"`
	DateReserved     string          `gorm:"column:date_reserved;type:varchar(255)"`
	DateUpdated      string          `gorm:"column:date_updated;type:varchar(255)"`
	State            string          `gorm:"column:state;type:varchar(255)"`
	DataType         string          `gorm:"column:data_type;type:varchar(255)"`
	DataVersion      string          `gorm:"column:data_version;type:varchar(255)"`
	// CVEReferences    json.RawMessage `gorm:"column:cve_references;type:jsonb"`
	RawJSON          json.RawMessage `gorm:"column:raw_json;type:jsonb"`
}

func (CVERecord) TableName() string {
	return "cve.cve_records"
}


type JSONData struct {
	CVEMetadata struct {
		CVEID         		string `json:"cveId"`
		AssignerOrgId 		string `json:"assignerOrgId"`
		AssignerShortName 	string `json:"assignerShortName"`
		DatePublished 		string `json:"datePublished"`
		DateRejected		string `json:"dateRejected"`
		DateReserved		string `json:"dateReserved"`
		DateUpdated   		string `json:"dateUpdated"`
		State				string `json:"state"`
	} `json:"cveMetadata"`
	DataType    string `json:"dataType"`
	DataVersion string `json:"dataVersion"`
}

func main() {
	// Setup logger
	logFile, err := os.OpenFile("cve_import.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("Error opening log file: %v", err)
	}
	defer logFile.Close()

	gormLogger := logger.New(
		log.New(logFile, "\r\n", log.LstdFlags),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Info,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)

	// Connect to PostgreSQL using GORM
	dsn := "host=host.docker.internal user=cve_user password=notapassword dbname=cve port=5432 sslmode=disable"
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: gormLogger,
	})
	if err != nil {
		gormLogger.Error(nil, "Error connecting to database: %v", err)
		return
	}

	// Path to the root directory containing year and version folders
	rootPath := "/opt/app/cves"

	var totalFiles, processedFiles, skippedFiles, failedFiles int

	// Recursively process JSON files
	err = filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			gormLogger.Error(nil, "Error accessing path %s: %v", path, err)
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".json") {
			totalFiles++
			err := processJSONFile(db, path, gormLogger)
			if err != nil {
				gormLogger.Error(nil, "Error processing file %s: %v", path, err)
				failedFiles++
			} else {
				processedFiles++
			}
		}

		return nil
	})

	if err != nil {
		gormLogger.Error(nil, "Error walking through directories: %v", err)
		return
	}

	gormLogger.Info(nil, "Import process completed. Total files: %d, Processed: %d, Skipped: %d, Failed: %d",
		totalFiles, processedFiles, skippedFiles, failedFiles)

		for {
			fmt.Println("Running...")
			time.Sleep(1 * time.Second) // Sleep for 1 second to avoid excessive CPU usage
		}
	
}

// processJSONFile inserts JSON data into the database from a file
func processJSONFile(db *gorm.DB, filePath string, gormLogger logger.Interface) error {
	gormLogger.Info(nil, "Processing file: %s", filePath)

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("error reading file %s: %v", filePath, err)
	}

	// Start a transaction
	tx := db.Begin()
	if tx.Error != nil {
		return fmt.Errorf("error starting transaction: %v", tx.Error)
	}

	// Insert data into the database
	err = processJSONBytes(tx, data, gormLogger)
	if err != nil {
		// Rollback transaction if an error occurs
		tx.Rollback()
		return fmt.Errorf("error inserting JSON data into DB: %v", err)
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		return fmt.Errorf("error committing transaction: %v", err)
	}

	return nil
}

// processJSONBytes inserts JSON data into the database
func processJSONBytes(db *gorm.DB, jsonData []byte, gormLogger logger.Interface) error {
	var record CVERecord
	record.RawJSON = jsonData

	// Unmarshal JSON data
	var jsonDataStruct JSONData
	err := json.Unmarshal(jsonData, &jsonDataStruct)
	if err != nil {
		return fmt.Errorf("error unmarshalling JSON data: %v", err)
	}

	// Set CVE metadata
	record.CVEID = jsonDataStruct.CVEMetadata.CVEID
	record.AssignerOrgId = jsonDataStruct.CVEMetadata.AssignerOrgId
	record.AssignerShortName = jsonDataStruct.CVEMetadata.AssignerShortName
	record.DatePublished = jsonDataStruct.CVEMetadata.DatePublished
	record.DateRejected = jsonDataStruct.CVEMetadata.DateRejected
	record.DateReserved = jsonDataStruct.CVEMetadata.DateReserved
	record.DateUpdated = jsonDataStruct.CVEMetadata.DateUpdated
	record.State = jsonDataStruct.CVEMetadata.State
	record.DataType = jsonDataStruct.DataType
	record.DataVersion = jsonDataStruct.DataVersion


	// Insert data into the database
	if err := db.Transaction(func(tx *gorm.DB) error {
		// Check if a record with the same cve_id exists
		var existingRecord CVERecord
		result := tx.Where("cve_id = ?", record.CVEID).First(&existingRecord)
		if result.Error != nil && !errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return fmt.Errorf("error checking existing record: %v", result.Error)
		}
	
		// If a record exists and date_updated is different, create a new record
		if !errors.Is(result.Error, gorm.ErrRecordNotFound) {
			if existingRecord.DateUpdated != record.DateUpdated {
				if err := tx.Create(&record).Error; err != nil {
					return fmt.Errorf("error inserting data: %v", err)
				}
				return nil
			}
			// If date_updated is the same, do nothing
			return nil
		}
	
		// If no record exists, create a new one
		if err := tx.Create(&record).Error; err != nil {
			return fmt.Errorf("error inserting data: %v", err)
		}
	
		return nil
	}); err != nil {
		return fmt.Errorf("error processing transaction: %v", err)
	}
	

	gormLogger.Info(nil, "Inserted Row in table")
	return nil
}
